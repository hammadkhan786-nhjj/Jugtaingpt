<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ProChat 5.0 â€” Realistic Chatbot</title>
<style>
  :root{--bg:#071019;--card:#0d1720;--muted:#9fb1c8;--accent:#2f81f7;--ok:#1f883d}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6edf3}
  .wrap{max-width:1100px;margin:12px auto;padding:12px;display:grid;grid-template-columns:280px 1fr 320px;gap:12px}
  .panel{background:linear-gradient(180deg,#07121a,#07141b);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03)}
  .sidebar{display:flex;flex-direction:column;height:82vh}
  .brand{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7b2dfd);display:flex;align-items:center;justify-content:center;font-weight:700}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:inherit;cursor:pointer}
  .btn.primary{background:var(--accent);color:#fff;border:none}
  .convos{flex:1;overflow:auto;margin-top:8px;padding-right:6px}
  .convo{padding:10px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center;cursor:pointer}
  .convo .meta{font-size:12px;color:var(--muted)}
  /* main */
  .main{display:flex;flex-direction:column;height:82vh}
  #chat{flex:1;overflow:auto;padding:12px;border-radius:10px;background:linear-gradient(180deg,#061217,#07131a);border:1px solid rgba(255,255,255,0.02)}
  .msg{max-width:72%;padding:10px;margin:8px;border-radius:10px;white-space:pre-wrap;line-height:1.4}
  .msg.user{margin-left:auto;background:linear-gradient(180deg,#083a5b,#06406b)}
  .msg.assistant{margin-right:auto;background:linear-gradient(180deg,#0f2130,#0b1822)}
  .inputRow{display:flex;gap:8px;margin-top:8px;align-items:center}
  textarea{flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;resize:none}
  .right{display:flex;flex-direction:column;gap:8px;height:82vh}
  label{font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="text"], input[type="number"], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .small{font-size:12px;color:var(--muted)}
  footer.small{font-size:12px;color:var(--muted);text-align:center;margin-top:6px}
  @media(max-width:1000px){
    .wrap{grid-template-columns:1fr;grid-auto-rows:auto}
    .sidebar,.right{height:auto}
    .main{height:auto}
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- Sidebar -->
  <div class="panel sidebar">
    <div class="brand"><div class="logo">PC</div><div><strong>ProChat 5.0</strong><div class="small">Realistic AI chatbot</div></div></div>
    <div class="controls">
      <button class="btn primary" id="newBtn">+ New</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn" id="importBtn">Import</button>
    </div>

    <div class="small">Search</div>
    <input id="search" placeholder="Search messages or title" style="margin:8px 0;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04)">

    <div class="convos" id="convos"></div>
    <div class="small" style="margin-top:8px">Conversations are stored locally (this device).</div>
  </div>

  <!-- Main -->
  <div class="panel main">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
      <div>
        <div><strong id="titleLabel">New Conversation</strong></div>
        <div class="small" id="metaLabel">No messages</div>
      </div>
      <div style="display:flex;gap:8px">
        <button class="btn" id="renameBtn">Rename</button>
        <button class="btn" id="clearBtn">Clear</button>
        <button class="btn" id="deleteBtn">Delete</button>
      </div>
    </div>

    <div id="chat" aria-live="polite"></div>

    <div class="inputRow">
      <textarea id="input" rows="2" placeholder="Type message..."></textarea>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button class="btn primary" id="sendBtn">Send</button>
        <button class="btn" id="regenBtn">Regenerate</button>
        <button class="btn" id="voiceBtn">ðŸŽ¤</button>
      </div>
    </div>
    <footer class="small">Tip: Use Settings (right) to set Proxy or API key. Proxy recommended.</footer>
  </div>

  <!-- Right: settings -->
  <div class="panel right">
    <div>
      <label>System persona</label>
      <input id="persona" placeholder="You are a concise bilingual assistant (Urdu & English)...">
    </div>

    <div>
      <label>API Mode</label>
      <select id="apiMode">
        <option value="proxy">Proxy (recommended)</option>
        <option value="direct">Direct (unsafe)</option>
        <option value="offline">Offline demo</option>
      </select>
    </div>

    <div id="proxyBlock">
      <label>Proxy URL</label>
      <input id="proxyUrl" placeholder="https://your-proxy.example.com/chat">
      <div class="small">Proxy should accept POST JSON { model, input, max_output_tokens } and return { output_text } or equivalent.</div>
    </div>

    <div id="keyBlock" style="display:none">
      <label>OpenAI API Key (sk-...)</label>
      <input id="apiKey" placeholder="sk-... (do not publish)">
      <div class="small">Direct mode will use this key in browser (unsafe to share).</div>
    </div>

    <div>
      <label>Model</label>
      <input id="model" value="gpt-4.1-mini">
    </div>

    <div>
      <label>Context length (rounds)</label>
      <input id="context" type="number" value="6" min="1" max="20">
    </div>

    <div>
      <label>Max tokens</label>
      <input id="maxTokens" type="number" value="400">
    </div>

    <div style="display:flex;gap:8px;margin-top:8px">
      <button class="btn primary" id="saveSettings">Save</button>
      <button class="btn" id="clearAll">Clear All</button>
    </div>

    <div style="margin-top:10px" class="small">Voice: Speech Recognition & Synthesis supported (browser dependent).</div>
  </div>
</div>

<script>
/* ---------------------------
  ProChat 5.0 Single-file JS
  - localStorage key: prochat5_v1
  - supports proxy/direct/offline
----------------------------*/

const STORAGE_KEY = 'prochat5_v1';

function defaultState(){
  return {
    settings: {
      persona: "You are ProChat, a helpful bilingual assistant (Urdu & English). Be concise and helpful.",
      apiMode: "proxy", // proxy | direct | offline
      proxyUrl: "",
      apiKey: "",
      model: "gpt-4.1-mini",
      maxTokens: 400,
      contextRounds: 6
    },
    convos: []
  };
}

let state = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || defaultState();

// DOM refs
const convosEl = document.getElementById('convos');
const newBtn = document.getElementById('newBtn');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const searchInput = document.getElementById('search');

const chatEl = document.getElementById('chat');
const titleLabel = document.getElementById('titleLabel');
const metaLabel = document.getElementById('metaLabel');
const inputEl = document.getElementById('input');
const sendBtn = document.getElementById('sendBtn');
const regenBtn = document.getElementById('regenBtn');
const voiceBtn = document.getElementById('voiceBtn');

const personaEl = document.getElementById('persona');
const apiModeEl = document.getElementById('apiMode');
const proxyUrlEl = document.getElementById('proxyUrl');
const apiKeyEl = document.getElementById('apiKey');
const modelEl = document.getElementById('model');
const contextEl = document.getElementById('context');
const maxTokensEl = document.getElementById('maxTokens');
const saveSettingsBtn = document.getElementById('saveSettings');
const clearAllBtn = document.getElementById('clearAll');

const keyBlock = document.getElementById('keyBlock');
const proxyBlock = document.getElementById('proxyBlock');

let currentId = null;
let recognizer = null;
let speaking = false;

/* ---------- helpers ---------- */
function uid(n=8){ return Math.random().toString(36).slice(2,2+n); }
function now(){ return Date.now(); }
function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function formatDate(ts){ return new Date(ts).toLocaleString(); }
function ensureConvo(){
  if(!currentId){
    const c = createConvo("Conversation " + (state.convos.length+1));
    setCurrent(c.id);
  }
}
function createConvo(title){
  const c = { id: uid(10), title: title||"New Conversation", createdAt: now(), updatedAt: now(), messages:[ {role:'system',content: state.settings.persona, ts:now()} ]};
  state.convos.unshift(c);
  save();
  renderConvos();
  return c;
}
function findConvo(id){ return state.convos.find(x=>x.id===id); }

/* ---------- render ---------- */
function renderConvos(filter=''){
  convosEl.innerHTML = '';
  const list = state.convos.filter(c=>{
    if(!filter) return true;
    const f = filter.toLowerCase();
    if(c.title.toLowerCase().includes(f)) return true;
    for(const m of c.messages) if((m.content||'').toLowerCase().includes(f)) return true;
    return false;
  });
  for(const c of list){
    const d = document.createElement('div');
    d.className = 'convo';
    d.dataset.id = c.id;
    d.innerHTML = `<div><div style="font-weight:600">${escapeHtml(c.title)}</div><div class="meta">${formatDate(c.updatedAt)} â€¢ ${c.messages.length} msgs</div></div>`;
    d.addEventListener('click', ()=> setCurrent(c.id));
    convosEl.appendChild(d);
  }
}

function escapeHtml(s=''){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

function renderChat(c){
  chatEl.innerHTML = '';
  for(const m of c.messages){
    const div = document.createElement('div');
    div.className = 'msg ' + (m.role==='user' ? 'user' : (m.role==='system' ? 'assistant' : 'assistant'));
    let prefix = m.role==='user' ? 'You: ' : (m.role==='system' ? 'System: ' : 'Bot: ');
    div.textContent = prefix + m.content;
    chatEl.appendChild(div);
  }
  chatEl.scrollTop = chatEl.scrollHeight;
  titleLabel.textContent = c.title;
  metaLabel.textContent = `Messages: ${c.messages.length} â€¢ Updated: ${formatDate(c.updatedAt)}`;
}

/* ---------- select current ---------- */
function setCurrent(id){
  currentId = id;
  const c = findConvo(id);
  if(!c) return;
  renderChat(c);
  // highlight selection
  document.querySelectorAll('.convo').forEach(el=> el.style.outline = (el.dataset.id===id? '2px solid rgba(47,129,247,0.15)':'none'));
}

/* ---------- message flow ---------- */
function addMessage(id, role, content){
  const c = findConvo(id);
  if(!c) return;
  c.messages.push({role, content, ts:now()});
  c.updatedAt = now();
  save();
  if(currentId===id) renderChat(c);
  renderConvos(searchInput.value.trim());
}

/* ---------- build prompt with context ---------- */
function buildInput(c){
  const persona = state.settings.persona;
  const rounds = Number(contextEl.value || state.settings.contextRounds || 6);
  const msgs = c.messages.filter(m=>m.role!=='system');
  const recent = msgs.slice(-rounds*2);
  let input = `SYSTEM: ${persona}\n\n`;
  for(const m of recent){
    input += `${m.role.toUpperCase()}: ${m.content}\n\n`;
  }
  if(c.messages.length > rounds*4){
    // local short summary of older text to reduce tokens (very naive)
    const older = c.messages.slice(0, Math.max(0,c.messages.length - rounds*2)).filter(m=>m.role!=='system').map(m=>m.content).join('\n\n');
    input = `SYSTEM: ${persona}\n\nSUMMARY_OF_OLDER: ${older.slice(0,600)}\n\n` + input;
  }
  return input;
}

/* ---------- call AI ---------- */
async function callAI(payload){
  const mode = state.settings.apiMode;
  if(mode === 'offline') {
    await new Promise(r=>setTimeout(r,600));
    return { ok:true, text: "Offline demo reply: connect proxy or direct API for real responses." };
  }
  if(mode === 'proxy'){
    const url = state.settings.proxyUrl;
    if(!url) return { ok:false, error:"Proxy URL not configured." };
    try{
      const r = await fetch(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
      const d = await r.json();
      return { ok:true, text: d.output_text || d.output?.[0]?.content?.[0]?.text || d.choices?.[0]?.message?.content || JSON.stringify(d) };
    }catch(err){ return { ok:false, error: err.message }; }
  }
  if(mode === 'direct'){
    const key = state.settings.apiKey;
    if(!key) return { ok:false, error:"API key not set." };
    try{
      const r = await fetch("https://api.openai.com/v1/responses", {
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer ' + key },
        body: JSON.stringify(payload)
      });
      const d = await r.json();
      return { ok:true, text: d.output_text || d.output?.[0]?.content?.[0]?.text || d.choices?.[0]?.message?.content || JSON.stringify(d) };
    }catch(err){ return { ok:false, error: err.message }; }
  }
  return { ok:false, error:'Unknown API mode' };
}

let lastCallPromise = null;
async function sendMessage(text){
  ensureConvo();
  const c = findConvo(currentId);
  if(!c) return;
  addMessage(c.id, 'user', text);
  addMessage(c.id, 'assistant', 'â€¦thinkingâ€¦'); // placeholder
  const placeholderIndex = c.messages.length - 1;

  const inputStr = buildInput(c) + `USER: ${text}`;
  const payload = { model: state.settings.model || 'gpt-4.1-mini', input: inputStr, max_output_tokens: Number(state.settings.maxTokens || 400), temperature: 0.7 };

  sendBtn.disabled = true; regenBtn.disabled = true;
  lastCallPromise = callAI(payload);
  const r = await lastCallPromise;
  if(!r.ok){
    c.messages[placeholderIndex].content = 'Error: ' + (r.error || 'unknown');
  } else {
    c.messages[placeholderIndex].content = r.text;
    // optional: auto-generate title if not set
    if(!c.title || c.title.startsWith('Conversation')) {
      c.title = (text.slice(0,40) || 'Conversation').trim();
    }
  }
  c.updatedAt = now();
  save();
  renderChat(c);
  sendBtn.disabled = false; regenBtn.disabled = false;
}

/* ---------- UI events ---------- */
newBtn.addEventListener('click', ()=> { const c = createConvo('Conversation ' + (state.convos.length+1)); setCurrent(c.id); });
exportBtn.addEventListener('click', ()=> {
  const blob = new Blob([JSON.stringify(state, null,2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'prochat_export_'+Date.now()+'.json'; a.click();
});
importBtn.addEventListener('click', ()=> {
  const inp = document.createElement('input'); inp.type='file'; inp.accept='.json';
  inp.onchange = async e=>{
    const f = e.target.files[0]; if(!f) return;
    const txt = await f.text(); try { const obj = JSON.parse(txt); if(obj.convos){ state = obj; save(); renderConvos(); if(state.convos.length) setCurrent(state.convos[0].id); alert('Imported'); } else alert('Invalid file'); } catch(err){ alert('Parse error: '+err.message); }
  }; inp.click();
});
searchInput.addEventListener('input', ()=> renderConvos(searchInput.value.trim()));

/* send/regenerate/voice */
sendBtn.addEventListener('click', ()=> { const t = inputEl.value.trim(); if(!t) return; sendMessage(t); inputEl.value=''; });
regenBtn.addEventListener('click', async ()=> {
  const c = findConvo(currentId); if(!c) return;
  // find last user message
  for(let i=c.messages.length-1;i>=0;i--){
    if(c.messages[i].role === 'user'){
      const lastUser = c.messages[i].content;
      c.messages = c.messages.slice(0, i+1); save(); renderChat(c);
      await sendMessage(lastUser);
      return;
    }
  }
  alert('No previous user message to regenerate.');
});

/* settings save */
saveSettingsBtn.addEventListener('click', ()=> {
  state.settings.persona = personaEl.value.trim() || state.settings.persona;
  state.settings.apiMode = apiModeEl.value;
  state.settings.proxyUrl = proxyUrlEl.value.trim();
  state.settings.apiKey = apiKeyEl.value.trim();
  state.settings.model = modelEl.value.trim();
  state.settings.maxTokens = Number(maxTokensEl.value) || state.settings.maxTokens;
  save();
  alert('Settings saved');
  // toggle blocks
  keyBlock.style.display = (state.settings.apiMode === 'direct') ? 'block' : 'none';
  proxyBlock.style.display = (state.settings.apiMode === 'proxy') ? 'block' : 'none';
  renderConvos();
});
clearAllBtn.addEventListener('click', ()=> { if(confirm('Clear all saved data?')) { localStorage.removeItem(STORAGE_KEY); state = defaultState(); save(); renderConvos(); chatEl.innerHTML=''; currentId=null; } });

/* rename/clear/delete (top buttons) */
document.getElementById('renameBtn').addEventListener('click', ()=> {
  const c = findConvo(currentId); if(!c) return alert('Select a convo'); const t = prompt('New title', c.title); if(t!=null){ c.title = t; c.updatedAt = now(); save(); renderConvos(); setCurrent(c.id); }
});
document.getElementById('clearBtn').addEventListener('click', ()=> {
  const c = findConvo(currentId); if(!c) return; if(confirm('Clear messages?')){ c.messages = [{role:'system',content: state.settings.persona, ts:now()}]; c.updatedAt = now(); save(); renderChat(c); renderConvos(); }
});
document.getElementById('deleteBtn').addEventListener('click', ()=> {
  const idx = state.convos.findIndex(x=>x.id===currentId); if(idx<0) return; if(confirm('Delete convo?')){ state.convos.splice(idx,1); save(); renderConvos(); if(state.convos.length) setCurrent(state.convos[0].id); else { currentId=null; chatEl.innerHTML=''; titleLabel.textContent='New Conversation'; } }
});

/* voice input & output (basic) */
voiceBtn.addEventListener('click', ()=> {
  if(!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    alert('Speech recognition not supported in this browser.');
    return;
  }
  if(!recognizer){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognizer = new SR();
    recognizer.lang = 'en-US';
    recognizer.interimResults = false;
    recognizer.onresult = (e)=> {
      const text = e.results[0][0].transcript;
      inputEl.value += (inputEl.value? ' ' : '') + text;
    };
    recognizer.onend = ()=> { recognizer=null; voiceBtn.textContent='ðŸŽ¤'; };
    recognizer.onerror = ()=> { recognizer=null; voiceBtn.textContent='ðŸŽ¤'; };
    recognizer.start(); voiceBtn.textContent='Listening...';
  } else {
    recognizer.stop(); recognizer=null; voiceBtn.textContent='ðŸŽ¤';
  }
});

function speak(text){
  if(!('speechSynthesis' in window)) return;
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = 'en-US';
  speechSynthesis.speak(utter);
}

/* ---------- init ---------- */
personaEl.value = state.settings.persona;
apiModeEl.value = state.settings.apiMode;
proxyUrlEl.value = state.settings.proxyUrl;
apiKeyEl.value = state.settings.apiKey;
modelEl.value = state.settings.model;
contextEl.value = state.settings.contextRounds;
maxTokensEl.value = state.settings.maxTokens;
keyBlock.style.display = (state.settings.apiMode === 'direct') ? 'block' : 'none';
proxyBlock.style.display = (state.settings.apiMode === 'proxy') ? 'block' : 'none';

renderConvos();
if(state.convos.length) setCurrent(state.convos[0].id);
else { const c=createConvo('Welcome'); addMessage(c.id,'assistant','Salaam! Welcome to ProChat 5.0 â€” set Proxy or API key in Settings to start.'); setCurrent(c.id); }

/* expose quick debug in console (only on localhost) */
if(location.hostname==='localhost' || location.hostname==='127.0.0.1') window._PROCHAT = state;

/* ---------- where to put API key / proxy ---------- */
/*
  -> To use OpenAI securely: set API Mode = "proxy" and deploy a serverless function that forwards requests to OpenAI.
     Put that function URL into Settings -> Proxy URL.

  -> If you only want to test locally & do not plan to publish the HTML:
     set API Mode = "direct" and paste your API key into Settings -> OpenAI API Key.
     DO NOT commit/publish your key anywhere public.

  Example Proxy payload expected by this HTML:
    POST { model, input, max_output_tokens, temperature? }
    Response should be JSON with either:
      { "output_text": "..." } or { "choices": [ { "message": { "content": "..." } } ] }
*/

</script>
</body>
</html>